@page "/game"
@using Po.PoDropSquare.Blazor.Models
@using Po.PoDropSquare.Blazor.Components
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation

<PageTitle>PoDropSquare</PageTitle>

<div class="game-page">
    <!-- Game Section -->
    <div class="game-section">
        <div class="game-header">
            <h1 class="game-title">PoDropSquare</h1>
            
            <!-- Minimal HUD - Only Timer and Score -->
            <div class="game-hud">
                <div class="timer-display">
                    <TimerDisplay 
                        Config="_timerConfig"
                        IsActive="_gameState == GameState.Playing"
                        ShowGameTime="false"
                        ShowProgress="false"
                        ShowLabel="false"
                        OnTimeUp="OnTimeUp"
                        OnTimeChanged="OnTimeChanged"
                        @ref="_timerRef" />
                </div>
                
                <div class="score-display">
                    <span class="score-value">@_currentScore</span>
                </div>
            </div>
        </div>

        <div class="game-canvas-container">
            <GameCanvas 
                CanvasId="mainGameCanvas"
                CanvasWidth="300"
                CanvasHeight="200"
                OnGameEvent="OnGameEvent"
                OnScoreChanged="OnScoreChanged"
                OnGameStateChanged="OnGameStateChanged"
                @ref="_gameCanvasRef" />
                
            @if (_gameState == GameState.NotStarted || _gameState == GameState.GameOver)
            {
                <div class="game-overlay">
                    <div class="overlay-content">
                        @if (_gameState == GameState.NotStarted)
                        {
                            <h2>Click to Start</h2>
                            <p>Drop blocks by clicking</p>
                        }
                        else if (_showGameOverScreen)
                        {
                            @if (_isVictory)
                            {
                                <h2>üèÜ Victory! üèÜ</h2>
                                <p>You held a block above the red line for 2 seconds!</p>
                                <p>Score: @_finalScore</p>
                                <p>Time: @FormatTime(_finalGameTime ?? TimeSpan.Zero)</p>
                                <button class="restart-btn" @onclick="RestartGame">Play Again</button>
                            }
                            else
                            {
                                <h2>Game Over</h2>
                                <p>Score: @_finalScore</p>
                                <p>Time: @FormatTime(_finalGameTime ?? TimeSpan.Zero)</p>
                                <button class="restart-btn" @onclick="RestartGame">Play Again</button>
                            }
                        }
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@code {
    // Component references
    private GameCanvas? _gameCanvasRef;
    private TimerDisplay? _timerRef;

    // Game state - Simplified
    private GameState _gameState = GameState.NotStarted;
    private int _currentScore = 0;
    private int _blocksPlaced = 0;
    private TimeSpan _currentGameTime = TimeSpan.Zero;
    private DateTime _gameStartTime;
    
    // End game state
    private bool _showGameOverScreen = false;
    private bool _isVictory = false;
    private int _finalScore = 0;
    private TimeSpan? _finalGameTime;
    
    // Configuration - Simplified
    private TimerConfig _timerConfig = new() { TotalSeconds = 300 }; // 5 minutes

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Auto-start on first load
            await Task.Delay(1000); // Brief delay for initialization
            await StartGame();
        }
    }

    private async Task StartGame()
    {
        _gameState = GameState.Playing;
        _blocksPlaced = 0;
        _currentScore = 0;
        _showGameOverScreen = false;
        _isVictory = false;
        
        if (_gameCanvasRef != null)
        {
            _gameStartTime = DateTime.UtcNow;
            _currentGameTime = TimeSpan.Zero;
            
            await InvokeAsync(StateHasChanged);
            
            _timerRef?.StartTimer();
            await _gameCanvasRef.StartGame();
        }
    }

    private async Task RestartGame()
    {
        _timerRef?.ResetTimer();
        await Task.Delay(500);
        await StartGame();
    }

    private void OnGameStateChanged(GameState newState)
    {
        _gameState = newState;
        StateHasChanged();
    }

    private void OnScoreChanged(ScoreChangedArgs args)
    {
        // Simplified Scoring: blocks placed √ó seconds survived
        _currentGameTime = args.GameTime;
        var secondsSurvived = (int)_currentGameTime.TotalSeconds;
        _currentScore = _blocksPlaced * Math.Max(1, secondsSurvived);
        StateHasChanged();
    }

    private async Task OnGameEvent(GameEventArgs args)
    {
        switch (args.EventType)
        {
            case GameEventType.BlockLanded:
                _blocksPlaced++;
                // Update score immediately when block is placed
                var currentSeconds = (int)_currentGameTime.TotalSeconds;
                _currentScore = _blocksPlaced * Math.Max(1, currentSeconds);
                break;
                
            case GameEventType.GameOver:
                await EndGame();
                break;
                
            case GameEventType.GoalReached:
                await EndGameWithVictory();
                break;
        }
        
        StateHasChanged();
    }

    private async Task OnTimeUp()
    {
        await EndGame();
    }

    private void OnTimeChanged(TimeSpan remaining)
    {
        // Update score based on time survived
        var secondsSurvived = 300 - (int)remaining.TotalSeconds;
        _currentScore = _blocksPlaced * Math.Max(1, secondsSurvived);
        StateHasChanged();
    }

    private async Task EndGame()
    {
        _finalScore = _currentScore;
        _finalGameTime = _currentGameTime;
        _gameState = GameState.GameOver;
        _showGameOverScreen = true;
        _isVictory = false;
        
        _timerRef?.StopTimer();
        
        if (_gameCanvasRef != null)
        {
            await _gameCanvasRef.StopGame();
        }
        
        await InvokeAsync(StateHasChanged);
    }

    private async Task EndGameWithVictory()
    {
        _finalScore = _currentScore;
        _finalGameTime = _currentGameTime;
        _gameState = GameState.GameOver;
        _showGameOverScreen = true;
        _isVictory = true;
        
        _timerRef?.StopTimer();
        
        if (_gameCanvasRef != null)
        {
            await _gameCanvasRef.StopGame();
        }
        
        await InvokeAsync(StateHasChanged);
    }

    private string FormatTime(TimeSpan time)
    {
        return $"{time.Minutes:D2}:{time.Seconds:D2}";
    }
}
