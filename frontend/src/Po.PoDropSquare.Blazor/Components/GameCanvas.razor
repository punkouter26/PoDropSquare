@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<div class="game-canvas-container">
    <canvas id="@CanvasId" 
            class="game-canvas"
            width="@CanvasWidth" 
            height="@CanvasHeight"
            @onclick="HandleClick"
            tabindex="0">
        Your browser does not support HTML5 Canvas.
    </canvas>
    
    @if (ShowGameOverlay)
    {
        <div class="game-overlay">
            <div class="game-status">
                @if (GameState == GameState.Loading)
                {
                    <div class="loading-spinner">
                        <div class="spinner"></div>
                        <p>Initializing Physics Engine...</p>
                    </div>
                }
                else if (GameState == GameState.Paused)
                {
                    <div class="pause-screen">
                        <h2>Game Paused</h2>
                        <button class="btn btn-primary" @onclick="ResumeGame">Resume</button>
                    </div>
                }
            </div>
        </div>
    }
    
    @if (_isDangerCountdownActive)
    {
        <div class="victory-countdown-overlay">
            <div class="victory-countdown">
                <div class="victory-title">üèÜ VICTORY COUNTDOWN! üèÜ</div>
                <div class="countdown-timer">@_dangerCountdownElapsed.ToString("F1") / 2.0</div>
                <div class="victory-message">Keep block above red line!</div>
            </div>
        </div>
    }
    
    <div class="game-controls">
        <div class="control-instructions">
            <p><strong>Controls:</strong></p>
            <p>‚Üê ‚Üí Arrow Keys: Move block horizontally</p>
            <p>‚Üì Down Arrow: Drop block faster</p>
            <p>Space: Pause/Resume</p>
            <p>Click: Drop block at mouse position</p>
        </div>
    </div>
</div>

@code {
    [Parameter] public string CanvasId { get; set; } = "gameCanvas";
    [Parameter] public int CanvasWidth { get; set; } = 300;
    [Parameter] public int CanvasHeight { get; set; } = 200;
    [Parameter] public EventCallback<GameEventArgs> OnGameEvent { get; set; }
    [Parameter] public EventCallback<ScoreChangedArgs> OnScoreChanged { get; set; }
    [Parameter] public EventCallback<GameState> OnGameStateChanged { get; set; }

    private GameState _gameState = GameState.NotStarted;
    private bool _physicsInitialized = false;
    private DotNetObjectReference<GameCanvas>? _dotNetRef;
    private Timer? _gameTimer;
    private int _currentScore = 0;
    private DateTime _gameStartTime;
    private bool _isDisposed = false;

    // Victory countdown state
    private bool _isDangerCountdownActive = false;
    private double _dangerCountdownElapsed = 0;

    public GameState GameState 
    { 
        get => _gameState;
        private set 
        {
            if (_gameState != value)
            {
                _gameState = value;
                InvokeAsync(() => OnGameStateChanged.InvokeAsync(value));
                StateHasChanged();
            }
        }
    }

    public bool ShowGameOverlay => GameState == GameState.Loading || GameState == GameState.Paused;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeGame();
        }
    }

    private async Task InitializeGame()
    {
        try
        {
            GameState = GameState.Loading;
            
            // Create DotNet reference for JS interop callbacks
            _dotNetRef = DotNetObjectReference.Create(this);
            
            // Initialize physics engine (using global functions)
            var success = await JSRuntime.InvokeAsync<bool>("initializePhysics", CanvasId);
            
            if (!success)
            {
                throw new InvalidOperationException("Failed to initialize physics engine");
            }

            _physicsInitialized = true;

            // Set up game event callbacks
            await JSRuntime.InvokeVoidAsync("setGameCallbacks", _dotNetRef);
            
            // Start game timer for regular updates
            _gameTimer = new Timer(GameTick, null, TimeSpan.Zero, TimeSpan.FromMilliseconds(16)); // ~60 FPS
            
            GameState = GameState.Ready;
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to initialize game: {ex.Message}");
            GameState = GameState.Error;
        }
    }

    public async Task StartGame()
    {
        if (GameState != GameState.Ready && GameState != GameState.GameOver)
            return;

        try
        {
            _gameStartTime = DateTime.UtcNow;
            _currentScore = 0;
            
            // Reset physics world
            if (_physicsInitialized)
            {
                await JSRuntime.InvokeVoidAsync("resetGame");
                await JSRuntime.InvokeVoidAsync("startGame");
            }
            
            GameState = GameState.Playing;
            
            // Notify score change
            await OnScoreChanged.InvokeAsync(new ScoreChangedArgs { Score = _currentScore, GameTime = TimeSpan.Zero });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to start game: {ex.Message}");
        }
    }

    public async Task PauseGame()
    {
        if (GameState == GameState.Playing)
        {
            GameState = GameState.Paused;
            if (_physicsInitialized)
            {
                await JSRuntime.InvokeVoidAsync("pauseGame");
            }
        }
    }

    public async Task ResumeGame()
    {
        if (GameState == GameState.Paused)
        {
            GameState = GameState.Playing;
            if (_physicsInitialized)
            {
                await JSRuntime.InvokeVoidAsync("resumeGame");
            }
        }
    }

    public async Task StopGame()
    {
        if (GameState == GameState.Playing || GameState == GameState.Paused)
        {
            GameState = GameState.GameOver;
            if (_physicsInitialized)
            {
                await JSRuntime.InvokeVoidAsync("stopGame");
            }
            
            // Notify final score
            var gameTime = DateTime.UtcNow - _gameStartTime;
            await OnScoreChanged.InvokeAsync(new ScoreChangedArgs { Score = _currentScore, GameTime = gameTime });
            await OnGameEvent.InvokeAsync(new GameEventArgs { EventType = GameEventType.GameOver, Score = _currentScore });
        }
    }

    private async void GameTick(object? state)
    {
        if (_isDisposed || GameState != GameState.Playing || !_physicsInitialized)
            return;

        try
        {
            // Update physics
            await JSRuntime.InvokeVoidAsync("updatePhysics");
            
            // Update game time
            var gameTime = DateTime.UtcNow - _gameStartTime;
            await InvokeAsync(() => OnScoreChanged.InvokeAsync(new ScoreChangedArgs { Score = _currentScore, GameTime = gameTime }));
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Game tick error: {ex.Message}");
        }
    }

    // Simplified input handler - Click to drop blocks
    private async Task HandleClick(MouseEventArgs e)
    {
        if (GameState == GameState.Playing && _physicsInitialized)
        {
            // Drop block at mouse position
            await JSRuntime.InvokeVoidAsync("dropBlockAtPosition", e.OffsetX, e.OffsetY);
            
            // Update game statistics
            await OnGameEvent.InvokeAsync(new GameEventArgs 
            { 
                EventType = GameEventType.BlockLanded
            });
        }
        else if (GameState == GameState.Ready)
        {
            await StartGame();
        }
    }

    // JavaScript callbacks
    [JSInvokable]
    public async Task OnBlockLanded(int points, int totalScore)
    {
        _currentScore = totalScore;
        var gameTime = DateTime.UtcNow - _gameStartTime;
        await OnScoreChanged.InvokeAsync(new ScoreChangedArgs { Score = _currentScore, GameTime = gameTime });
        await OnGameEvent.InvokeAsync(new GameEventArgs { EventType = GameEventType.BlockLanded, Score = points });
    }

    [JSInvokable]
    public async Task OnLineCleared(int linesCleared, int points)
    {
        await OnGameEvent.InvokeAsync(new GameEventArgs { EventType = GameEventType.LineCleared, Score = points, Data = linesCleared });
    }

    [JSInvokable]
    public async Task OnGoalReached()
    {
        await StopGame();
        await OnGameEvent.InvokeAsync(new GameEventArgs { EventType = GameEventType.GoalReached, Score = _currentScore });
    }

    [JSInvokable]
    public async Task OnGameOverTriggered()
    {
        await StopGame();
    }

    [JSInvokable]
    public async Task OnDangerCountdownStarted()
    {
        _isDangerCountdownActive = true;
        _dangerCountdownElapsed = 0;
        Console.WriteLine("Danger countdown started!");
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task OnDangerCountdownUpdate(double elapsedSeconds)
    {
        _dangerCountdownElapsed = elapsedSeconds;
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task OnDangerCountdownCancelled()
    {
        _isDangerCountdownActive = false;
        _dangerCountdownElapsed = 0;
        Console.WriteLine("Danger countdown cancelled!");
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task OnDangerGameOver()
    {
        _isDangerCountdownActive = false;
        _dangerCountdownElapsed = 0;
        Console.WriteLine("Game over due to danger countdown!");
        await StopGame();
        await OnGameEvent.InvokeAsync(new GameEventArgs { EventType = GameEventType.GameOver, Score = _currentScore });
    }

    [JSInvokable]
    public async Task OnVictoryAchieved()
    {
        _isDangerCountdownActive = false;
        _dangerCountdownElapsed = 0;
        Console.WriteLine("Victory! Block held high for 2 seconds!");
        await StopGame();
        await OnGameEvent.InvokeAsync(new GameEventArgs { EventType = GameEventType.GoalReached, Score = _currentScore });
    }

    public async ValueTask DisposeAsync()
    {
        _isDisposed = true;
        
        _gameTimer?.Dispose();
        
        if (_physicsInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("cleanup");
            }
            catch { /* Ignore disposal errors */ }
        }
        
        _dotNetRef?.Dispose();
    }
}

<style>
    .danger-countdown-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 0, 0, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        pointer-events: none;
        animation: dangerPulse 0.5s ease-in-out infinite alternate;
    }

    .danger-countdown {
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 2rem;
        border-radius: 20px;
        text-align: center;
        border: 3px solid #fff;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        animation: shake 0.2s ease-in-out infinite;
    }

    .danger-title {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .countdown-timer {
        font-size: 3rem;
        font-weight: bold;
        margin: 1rem 0;
        color: #ffff00;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        font-family: 'Courier New', monospace;
    }

    .danger-message {
        font-size: 1.2rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    @@keyframes dangerPulse {
        0% { background: rgba(255, 0, 0, 0.1); }
        100% { background: rgba(255, 0, 0, 0.3); }
    }

    @@keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-2px); }
        75% { transform: translateX(2px); }
    }
</style>

